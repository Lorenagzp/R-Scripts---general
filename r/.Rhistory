#add date info in  column
#For every sampling date
for (s in 1:samplings) {
df.list[[s]]<-df.list[[s]][df.list[[s]]$id<=maxsp,] #Exclude points above 40 FOR ESCAMILLA etc
sPoints = length(df.list[[s]]$id) #total samples per date
for (i in 1:sPoints) {
print(paste("sampling",sheets[s],"sample",df.list[[s]]$id[i]))
df.list[[s]]$date[i] <- as.character(sheets[s]) #add date info in  column
}
}
return (list(df.list,sheets))
}
##Replace something in a column of a df list
replaceInCol <- function(df_list,col,txt_orig,txt_replace){
r_df_list<-df_list
for(i in 1:length(df_list)){
print(i)
l <- length (r_df_list[[i]][,col])
for(j in 1:l){
print(j)
print(df_list[[i]][j,col])
r_df_list[[i]][j,col] <- gsub(txt_orig, txt_replace, df_list[[i]][j,col])
}
}
return(r_df_list)
}
################################# EXECUTE SCRIPT
############# INPUTS
file="C://Dropbox//data//AD//AD-STARS//ros//ad_ros_ceptometer.xlsx"
trial <- "ros"
whatData <- "par" #What does this data represent
col_names<-c('id',
'par',
'par_time',
'par_ref',
'ref_time')
colTypes <- c('numeric', 'numeric', 'character','numeric','character')
maxsp<-25
##Edit next
##getMoistreFromExcel <- function (file, startSheet,endCol,endRow,colTypes,col_names,maxsamplepointID)
mData <- getCeptometerFromExcel(file, 2,5,26,colTypes,col_names,maxsp) #get the moisture data[[1]] and sheetnames[[2]]
############# END INPUTS
##Resulting data
dates<-mData[[2]]
mData <-mData[[1]]
##Replace the data "wrong date" in column 3 to keep the time only
#mData <- replaceInCol(mData,5,"1899-12-31 ","")
##Connecto to local Database
mydb = dbConnect(MySQL(), user='root', password='cimmyt', dbname='ac_stars', host='localhost')
#dbListFields(mydb, 'ros') #List fields on table
#Save moisture data to DB
for(i in 1:length(dates)){
##Check if table already exists...
tExists = dbSendQuery(mydb, paste("SHOW TABLES LIKE '", dates[[i]],"'",sep="")) ##ask if the table exists
data = dbFetch(tExists, n=-1) #get results. The n=-1 is to get all the results, can be used to set a MAX
if(length(row.names(data))==0){ #If the table doesnt exists
print(dates[[i]])
#withe df to DB
dbWriteTable(mydb, value = mData[[i]], name = paste(trial,dates[[i]],whatData,sep=""), row.names = FALSE) #THere is an issue vs append and autoincrement index
}
}
require(rgdal)
require(raster)
get_roi <- function(trial_roi) {readOGR(dsn=fgdb,layer=trial_roi)}
fgdb = "C:\\Dropbox\\data\\AE\\physio\\ae_fisio.gdb"
roi <- get_roi("hap__ae__bry")
dsm <- raster("G:/AE/161026/r161026fis/r161026hap/3_dsm_ortho/1_dsm/r161026hap_dsm.tif")
r_crop<-crop(dsm, extent(roi), snap="out")
roi
dsm
plot(dsm)
install.packages("shiny")
require(shiny)
runExample("01_hello")
setwd("C:/Dropbox/Software/Scripts/r")
runApp("shiny_extractPhysio")
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio',display.mode = "showcase")
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
install.packages(c("maps", "mapproj"))
percent_map <- function(var, color, legend.title, min = 0, max = 100) {
# generate vector of fill colors for map
shades <- colorRampPalette(c("white", color))(100)
# constrain gradient to percents that occur between min and max
var <- pmax(var, min)
var <- pmin(var, max)
percents <- as.integer(cut(var, 100,
include.lowest = TRUE, ordered = TRUE))
fills <- shades[percents]
# plot choropleth map
map("county", fill = TRUE, col = fills,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
# overlay state borders
map("state", col = "white", fill = FALSE, add = TRUE,
lty = 1, lwd = 1, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
# add a legend
inc <- (max - min) / 4
legend.text <- c(paste0(min, " % or less"),
paste0(min + inc, " %"),
paste0(min + 2 * inc, " %"),
paste0(min + 3 * inc, " %"),
paste0(max, " % or more"))
legend("bottomleft",
legend = legend.text,
fill = shades[c(1, 25, 50, 75, 100)],
title = legend.title)
}
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
runApp('shiny_extractPhysio')
library(reshape2)
library(plyr)
df
myFile = file.path("C:","Dropbox", "data","AE","ae_stars","ae_data_extract.csv", fsep = .Platform$file.sep)
dat = read.csv(myFile, stringsAsFactors = FALSE)
date <- dat$date
#Formatear como fechas las fechas
date <- as.Date(as.character(date),format = "%y%m%d")
# range_date <- range(date)
# all_dates <- seq(range_date[1],range_date[2],1)
# length(all_dates)
# length(date)
# which(all_dates %in% date)
#Vector lógico checando cuales fechas son en enero
if_enero <-  date >= as.Date("2017-01-01") & date <= as.Date("2017-1-31")
#porcentaje de las mediciones que fueron hechas en enero
#Todas / las de enero
sum(if_enero)/length(if_enero)
#subset las fechas que pertenecen a enero en base al vector lógico
mediciones_enero <- date [if_enero]
#plot(date, 1:13, type = "l") ## ejemplo de plot línea con fecha de mediciones
#### Otro tema
## Data frames
##CREate one
df = data.frame(
num = 1:4,
lower = c("a","b","c","d"),
upper = c("A","B","C","D"), stringsAsFactors = FALSE)
##Examine the object
str(df)
##Subset a column of the data Frame, but always keep the data frame class
df[ ,3, drop = FALSE]
#Subset with another method, including a conditional, and the names of columns
df[df$lower %in% c("a","d"), c("lower","upper")] ##x %in% table
# Exclude rows that are not complete
df[complete.cases(df),]
##Create a column based on a specific value of a cell (row)
df$word[df$num == 2] <- "two"
## create another column mixing the others
df$mix <- paste(df$num,df$lower,df$upper, sep="")
##Use of ifElse
ifelse(df >= 2, ">2", "menor")
"a" > 2
as.numeric("a")
#####Another subject
###Apply family
#tapply : apply a function across subsets
#data
df$categories <- c("1","1","2","2")
#Get the mean vakue of a column, by groups
#An array is returned
df$mean <- tapply(df$num,df$categories, mean) ##tapply(values, categories, function)
#Eliminate that just created column from the df "mean"
df <- df[, which(!(colnames(df) %in% "mean"))] #From the logical vector we get the indexes of the columns not named "mean"
#Check for missing values AKA NA's, an array is returned with its names
na_values <- tapply(df$word, df$upper, function (x) any(is.na(x)))
#columns with NA values
names(na_values[na_values])
##use the function apply. It can apply across rows or columns the functions
# parameter with value 1 or 2 refers if it should aggregate rows or columns
#Get the max from num and categories column
apply( df[, c("num","categories")], 2, max, na.rm =TRUE)
#paste values in the row
apply(df, 1, paste)
df
long_table <- melt(df, id.vars ="num")
long_table
dcast(long_table, ... ~ variable)
df
dcast(long_table, var1 ~ variable)
dcast(long_table, num+value ~ variable)
dcast(long_table, value ~ variable)
dcast(long_table, value+num ~ variable)
dcast(long_table, num ~ variable)
df = dcast(long_table, num ~ variable)
df
melt(df, id.vars =c("num","categories")
)
df <- dcast(long_table, num ~ variable)
df
long_table <- melt(df, id.vars =c("num","categories"))
df <- dcast(long_table, num ~ variable)
df
df <- dcast(long_table, ... ~ variable)
df
means_df <- dcast(long_table, categories ~ variable, mean)
means_df <- dcast(long_table, categories ~ variable, mean,  na.rm = TRUE)
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num))
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num),
mix_nonums = gsub("","",mix,fixed = TRUE))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num),
mix_nonums = gsub("[:alpha:]","",mix,fixed = FALSE))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num),
mix_nonums = gsub("[a-z]","",mix,fixed = FALSE))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num),
mix_nonums = gsub("a","",mix,fixed = FALSE))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num))
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num))
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix))
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
other = paste(mix))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
other = c(mix))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
other = mix)
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
other = mix[which.max(mix)])
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
NAs_index_word = which(is.na(word)))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
NAs_index_word = which(word[is.na(word)]))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
NAs_index_word = which(is.na(word)))
is.na(df$word)
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
NAs_index_word = which(is.na(df$word)))
is.na(df$word)
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
NAs_index_word = which(!(is.na(word)))
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
NAs_index_word = which(!(is.na(word))))
!(is.na(word))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix))
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
word_something = word[1])
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
word_something = word[2])
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
word_something = word[2],
sum_or_mean <- ifelse(categories == 1, sum(num),mean(num)))
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
word_something = word[2],
sum_or_mean <- ifelse(categories[1] == 1, sum(num),mean(num)))
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
word_ish = word[2],
sum_or_mean <- ifelse(categories[1] == 1, sum(num),mean(num)))
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_mean = mean(num),
nums_max = max(num*num),
l = length(mix),
word_ish = word[2],
sum_mean <- ifelse(categories[1] == 1, sum(num),mean(num)))
df_summ
df_summ <- ddply(df, .(categories), summarize,
nums_max = max(num*num),
l = length(mix),
word_ish = word[2],
sum_mean <- ifelse(categories[1] == 1, sum(num),mean(num)))
df_summ
season = rep(c("winter","spring","summer","fall"), each = 3)
season
combined = join(df,
df,
by = "num", type = "left", match="all")
combined
combined = join(df,
df_summ,
by = "categories", type = "left", match="all")
combined
combined = join(df,
df_summ,
by = "categories", type = "right", match="all")
combined
combined = join(df,
df_summ,
by = "categories", type = "left", match="all")
matrix(1:9,ncol=3)
matrix(1:9,ncol=3, byrow=TRUE)
m <- matrix(1:9,ncol=3, byrow=TRUE)
m
matrix(1:8,ncol=3, byrow=TRUE)
m <- matrix(1:8,ncol=4, byrow=TRUE)
m
matrix(12:1, ncol = 4, nrow = 2)
matrix(12:1, ncol = 4)
matrix(12:1, ncol = 8)
matrix(12:1, ncol = 8, nrow = 5)
mx <- matrix(12:1, ncol = 8, nrow = 5)
mx
ghdfg
length(m)
dim(m) #get dimensions
m
m <- matrix(1:8,ncol=4, byrow=TRUE)
length(m) #Get lenght
nrow(m) #Get num of rows
ncol(m) #Get num of columns
dim(m) #get dimensions
as.vector(x)
as.vector(m)
as.vector(m) # get as linear vector ordered by columns
m[2, , drop = FALSE]
class(m)
matrix(1:4, nrow = 2)
m[2:3, 1:2]
m <- matrix(1:9,ncol=3, byrow=TRUE)
m
m[2:3, 1:2]
m[2:3, 1:2] = matrix(22:19, nrow = 2)
m
m[2:3, 1:2] = matrix(-1:-4, nrow = 2)
m
colMeans(m)
apply(m,2,mean)
a = array(1:24, c(2,2,3))
a
a = array(1:24, c(2,2,3,2))
a
a = array(1:24, c(2,2,3,2,3))
a
a = array(1:24, c(2,2,3,2))
a
a = array(1:24, c(2,2,3))
a
time_array = array(NA, c(12,4,7,24))##Array that can store months of year, weeks, days, and hours of each day. Idea taken from Quora ask.
time_array
time_array = array(NA, c(4,7,12,24))##Array that can store months of year, weeks, days, and hours of each day. Idea taken from Quora ask.
time_array
time_array = array(NA, c(4,12,7,24))##Array that can store months of year, weeks, days, and hours of each day. Idea taken from Quora ask.
time_array
time_array = array(NA, c(12,4,7,24))##Array that can store months of year, weeks, days, and hours of each day. Idea taken from Quora ask.
time_array
colnames(time_array) <- c(rep("a",each = 12))
dimnames(time_array)
rep("a",each = 12)
colnames(time_array) <- c(rep("a",each = 4))
time_array
colnames(time_array) <- c("semana1","semana2", "semana3","semana4")
time_array
rownames(time_array) <- c(1:12)
time_array
lapply(1:12,paste, sep="_")
lapply(1:12,paste, "mes")
lapply(1:12,paste, "mes", sep="")
rownames(time_array) <- lapply(1:12,paste, "mes", sep="")
time_array
rownames(time_array) <- lapply("mes",paste, 1:12, sep="")
lapply("mes",paste, 1:12, sep="")
lapply("mes",paste, 1:12, sep=" ")
time_array
dimnames(time_array)[[3]]
dimnames(time_array)
dimnames(time_array)[[3]] <- c("Lun", "Mar", "Mier","Jue","sab","dom")
dimnames(time_array)[[3]] <- c("Lun", "Mar", "Mier","Jue","vier", "sab","dom")
dimnames(time_array)[[3]] <- c("Lun", "Mar", "Mier","Jue","vier", "sab","dom") #Set names for the 3 dimension
time_array
dimnames(time_array)[[4]] <- lapply(1:12,paste, "hora", sep="") #Set names for the 4th dimension
dimnames(time_array)[[4]] <- lapply(1:24,paste, "hora", sep="") #Set names for the 4th dimension
time_array
time_array = array(NA, c(7,24,4,12))##Array that can store values for months of year, weeks, days, and hours of each day. Idea taken from Quora ask.
time_array
time_array = array(NA, c(24,7,4,12))##Array that can store values for months of year, weeks, days, and hours of each day. Idea taken from Quora ask.
time_array
rownames(time_array) <- lapply(1:24,paste, "hora", sep="") #set rownames
colnames(time_array) <- c("Lun", "Mar", "Mier","Jue","vier", "sab","dom") #set column names
dimnames(time_array)[[3]] <- c("semana1","semana2", "semana3","semana4") #Set names for the 3 dimension
dimnames(time_array)[[4]] <- lapply(1:12,paste, "mes", sep="")
time_array
r1 = raster(m)
library(raster)
r1 = raster(m)
r1
plot(m)
plot(r1)
stack(r1, r1)
stack(r1, r1)
s <- stack(r1, r1)
s
s[[1:2]]
writeRaster(s,"C:\\vuelos\\temp\\img.tif",
format = "Gtiff",
overwrite = FALSE)
writeRaster(s,"C:\\vuelos\\temp\\img.tif",
format = "tiff",
overwrite = FALSE)
writeRaster(s,"C:\\vuelos\\temp\\img.tif",
format = "Gtif",
overwrite = FALSE)
nrows(s)
nrow(s)
nlayers(l_00) ## Get number of bands
nlayers(s) ## Get number of bands
dims(s) ##get dimensions
dim(s) ##get dimensions
res(s) ## get the spatial resolution
extent(s) ## get the bounds
proj4string(s)
CRS(proj4string(s)) ## Get the spatial reference, as a Coordinate Reference System Class CRS
names(s) #get the band names
rownames(time_array) <- paste("hora", 1:24, sep = "_") #set rownames
time_array
rownames(time_array) <- paste(1:24,":00", sep = "")
time_array
dimnames(time_array)[[4]] <- paste("mes",1:12, sep = "_") #Set names for the 4th dimension
time_array
names (s) <- c("band1","band2")
names (s)
writeRaster(s,"C:\\vuelos\\temp\\img.tif",
format = "GTiff",
overwrite = FALSE)
proj4string(s) <- CRS("+proj=utm +zone=36 +ellps=WGS84 +units=m +no_defs")
writeRaster(s,"C:\\vuelos\\temp\\img.tif",
format = "GTiff",
overwrite = FALSE)
writeRaster(s,"C:\\vuelos\\temp\\img.tif",
format = "GTiff",
overwrite = FALSE)
hist(s)
