wLTable$irrnum <- gsub('-', '',regmatches(wLTable$sheetName, regexpr("-[0-9A-Za-z]+$", wLTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(wLTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
wLTable <- wLTable[!na_inrow, ]
#Formate the date column to format the axis labels in ggplot
wLTable$date <- as.POSIXct(wLTable$date)
#write the final table to CSV if you want to save to text file
write.csv(wLTable,csvfile, row.names=FALSE)
mData
wLTable
na_inrow
wLTable
wLTable$irrtype <- regmatches(wLTable$sheetName, regexpr("bi|ai|ah|m1", wLTable$sheetName)) #español ar|dr|mv|dt|m1"
wLTable
write.csv(wLTable,csvfile, row.names=FALSE)
write.csv(wLTable,csvfile, row.names=FALSE)
rm(list=ls()
)
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
#Calculate water table  based on the moisture frome each measurement
samplings = length(dates)
waterLayerTable <- calculateWLayer(moistData,dates)
##Bind all samplings in one table (stack the rows, keep the columns)
wLTable <- Reduce(rbind,waterLayerTable)
##FORMATTING
#Format the headers (use if needed)
# wLTable$depth <- gsub('0-15', '1w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('15-30', '2w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('30-60', '3w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('60-90', '4w', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('0-15', 'depth1', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('15-30', 'depth2', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('30-60', 'depth3', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('60-90', 'depth4', wLTable$depth) #replace the depth by an ordered index
###########Separate the sheets name into columns (maybe change after the filtering thing?)
#The format should be something like: dr30-11-2015_pre-conv
#sheetname should be in a format dd-mm-yyyy and will have a prefix of 2 char: AR or DR or DT or MV (indicating the kind of sampling: after/before iirgation, etc)
#and a suffix indicating _[pre]/[2R]/[4R]-[1/2/3/4/5]/[pb]/[conv])
#date column - get what has the format of a date dd-mm-yyyy
wLTable$date <- as.Date(regmatches(wLTable$sheetName, regexpr("[0-9]{2}-[0-9]{2}-[0-9]{4}", wLTable$sheetName)),"%d-%m-%Y")
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, después, verano, trilla...)
wLTable$irrtype <- regmatches(wLTable$sheetName, regexpr("bi|ai|ah|m1", wLTable$sheetName)) #español ar|dr|mv|dt|m1"
#irrarea sampled column - the sampling corresponded to which irrigation instance: pre(siembra), 4R(4 riegos) or 2R(2 riegos)
wLTable$irrarea <- gsub('_', '',regmatches(wLTable$sheetName, regexpr("_[0-9A-Za-z]+", wLTable$sheetName)))
#irrigation sampled column - weather its the first, second.. irrigation etc
wLTable$irrnum <- gsub('-', '',regmatches(wLTable$sheetName, regexpr("-[0-9A-Za-z]+$", wLTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(wLTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
wLTable <- wLTable[!na_inrow, ]
#Formate the date column to format the axis labels in ggplot
wLTable$date <- as.POSIXct(wLTable$date)
#write the final table to CSV if you want to save to text file
write.csv(wLTable,csvfile, row.names=FALSE)
source(file.path("C:","Dropbox","Software","Scripts","r","moisture","methods_moisture.R", fsep = .Platform$file.sep))
###################################################### EXECUTE SCRIPT
############################### INPUTS
#set WDir
setwd("C://Dropbox//Software//Scripts//r//moisture")
file="C://Dropbox//data//AE//ae_stars//ser//AE-851 ANTILLON humedad.xlsx"
trial <- "ros"
col_names<-c('id',
'depth',
'canType',
'can',
'wSoilw',
'dSoilw',
'moisture')
colTypes <- c('numeric', 'character','numeric', 'numeric','numeric','numeric','numeric')
##Check this for every excel read
startRow<- 1 #Skip the fisrt 5 rows because it has other ancillary data
startSheet <- 2
endSheet <- 9
endCol <- 7
endRow <- 101
csvfile <- "C://Dropbox//data//AE//ae_stars//ser//waterLayer_humedad_AEser.csv"
################################# END INPUTS
##Edit next
##getMoistreFromExcel <- function (file, startSheet,endCol,endRow,colTypes,col_names,maxsamplepointID)
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
#Calculate water table  based on the moisture frome each measurement
samplings = length(dates)
waterLayerTable <- calculateWLayer(moistData,dates)
##Bind all samplings in one table (stack the rows, keep the columns)
wLTable <- Reduce(rbind,waterLayerTable)
##FORMATTING
#Format the headers (use if needed)
# wLTable$depth <- gsub('0-15', '1w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('15-30', '2w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('30-60', '3w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('60-90', '4w', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('0-15', 'depth1', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('15-30', 'depth2', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('30-60', 'depth3', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('60-90', 'depth4', wLTable$depth) #replace the depth by an ordered index
###########Separate the sheets name into columns (maybe change after the filtering thing?)
#The format should be something like: dr30-11-2015_pre-conv
#sheetname should be in a format dd-mm-yyyy and will have a prefix of 2 char: AR or DR or DT or MV (indicating the kind of sampling: after/before iirgation, etc)
#and a suffix indicating _[pre]/[2R]/[4R]-[1/2/3/4/5]/[pb]/[conv])
#date column - get what has the format of a date dd-mm-yyyy
wLTable$date <- as.Date(regmatches(wLTable$sheetName, regexpr("[0-9]{2}-[0-9]{2}-[0-9]{4}", wLTable$sheetName)),"%d-%m-%Y")
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, después, verano, trilla...)
wLTable$irrtype <- regmatches(wLTable$sheetName, regexpr("bi|ai|ah|m1", wLTable$sheetName)) #español ar|dr|mv|dt|m1"
#irrarea sampled column - the sampling corresponded to which irrigation instance: pre(siembra), 4R(4 riegos) or 2R(2 riegos)
wLTable$irrarea <- gsub('_', '',regmatches(wLTable$sheetName, regexpr("_[0-9A-Za-z]+", wLTable$sheetName)))
#irrigation sampled column - weather its the first, second.. irrigation etc
wLTable$irrnum <- gsub('-', '',regmatches(wLTable$sheetName, regexpr("-[0-9A-Za-z]+$", wLTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(wLTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
wLTable <- wLTable[!na_inrow, ]
#Formate the date column to format the axis labels in ggplot
wLTable$date <- as.POSIXct(wLTable$date)
#write the final table to CSV if you want to save to text file
write.csv(wLTable,csvfile, row.names=FALSE)
moistData
rm(list=ls())
source(file.path("C:","Dropbox","Software","Scripts","r","moisture","methods_moisture.R", fsep = .Platform$file.sep))
###################################################### EXECUTE SCRIPT
############################### INPUTS
#set WDir
setwd("C://Dropbox//Software//Scripts//r//moisture")
file="C://Dropbox//data//AE//ae_stars//ser//AE-851 ANTILLON humedad.xlsx"
trial <- "ros"
col_names<-c('id',
'depth',
'canType',
'can',
'wSoilw',
'dSoilw',
'moisture')
colTypes <- c('numeric', 'character','numeric', 'numeric','numeric','numeric','numeric')
##Check this for every excel read
startRow<- 1 #Skip the fisrt 5 rows because it has other ancillary data
startSheet <- 2
endSheet <- 9
endCol <- 7
endRow <- 101
csvfile <- "C://Dropbox//data//AE//ae_stars//ser//waterLayer_humedad_AEser.csv"
################################# END INPUTS
##Edit next
##getMoistreFromExcel <- function (file, startSheet,endCol,endRow,colTypes,col_names,maxsamplepointID)
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
#Calculate water table  based on the moisture frome each measurement
samplings = length(dates)
waterLayerTable <- calculateWLayer(moistData,dates)
##Bind all samplings in one table (stack the rows, keep the columns)
wLTable <- Reduce(rbind,waterLayerTable)
##FORMATTING
#Format the headers (use if needed)
# wLTable$depth <- gsub('0-15', '1w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('15-30', '2w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('30-60', '3w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('60-90', '4w', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('0-15', 'depth1', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('15-30', 'depth2', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('30-60', 'depth3', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('60-90', 'depth4', wLTable$depth) #replace the depth by an ordered index
###########Separate the sheets name into columns (maybe change after the filtering thing?)
#The format should be something like: dr30-11-2015_pre-conv
#sheetname should be in a format dd-mm-yyyy and will have a prefix of 2 char: AR or DR or DT or MV (indicating the kind of sampling: after/before iirgation, etc)
#and a suffix indicating _[pre]/[2R]/[4R]-[1/2/3/4/5]/[pb]/[conv])
#date column - get what has the format of a date dd-mm-yyyy
wLTable$date <- as.Date(regmatches(wLTable$sheetName, regexpr("[0-9]{2}-[0-9]{2}-[0-9]{4}", wLTable$sheetName)),"%d-%m-%Y")
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, después, verano, trilla...)
wLTable$irrtype <- regmatches(wLTable$sheetName, regexpr("bi|ai|ah|m1", wLTable$sheetName)) #español ar|dr|mv|dt|m1"
#irrarea sampled column - the sampling corresponded to which irrigation instance: pre(siembra), 4R(4 riegos) or 2R(2 riegos)
wLTable$irrarea <- gsub('_', '',regmatches(wLTable$sheetName, regexpr("_[0-9A-Za-z]+", wLTable$sheetName)))
#irrigation sampled column - weather its the first, second.. irrigation etc
wLTable$irrnum <- gsub('-', '',regmatches(wLTable$sheetName, regexpr("-[0-9A-Za-z]+$", wLTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(wLTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
wLTable <- wLTable[!na_inrow, ]
#Formate the date column to format the axis labels in ggplot
wLTable$date <- as.POSIXct(wLTable$date)
#write the final table to CSV if you want to save to text file
write.csv(wLTable,csvfile, row.names=FALSE)
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
#Calculate water table  based on the moisture frome each measurement
samplings = length(dates)
waterLayerTable <- calculateWLayer(moistData,dates)
##Bind all samplings in one table (stack the rows, keep the columns)
wLTable <- Reduce(rbind,waterLayerTable)
##FORMATTING
#Format the headers (use if needed)
# wLTable$depth <- gsub('0-15', '1w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('15-30', '2w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('30-60', '3w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('60-90', '4w', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('0-15', 'depth1', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('15-30', 'depth2', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('30-60', 'depth3', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('60-90', 'depth4', wLTable$depth) #replace the depth by an ordered index
###########Separate the sheets name into columns (maybe change after the filtering thing?)
#The format should be something like: dr30-11-2015_pre-conv
#sheetname should be in a format dd-mm-yyyy and will have a prefix of 2 char: AR or DR or DT or MV (indicating the kind of sampling: after/before iirgation, etc)
#and a suffix indicating _[pre]/[2R]/[4R]-[1/2/3/4/5]/[pb]/[conv])
#date column - get what has the format of a date dd-mm-yyyy
wLTable$date <- as.Date(regmatches(wLTable$sheetName, regexpr("[0-9]{2}-[0-9]{2}-[0-9]{4}", wLTable$sheetName)),"%d-%m-%Y")
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, después, verano, trilla...)
wLTable$irrtype <- regmatches(wLTable$sheetName, regexpr("bi|ai|ah|m1", wLTable$sheetName)) #español ar|dr|mv|dt|m1"
#irrarea sampled column - the sampling corresponded to which irrigation instance: pre(siembra), 4R(4 riegos) or 2R(2 riegos)
wLTable$irrarea <- gsub('_', '',regmatches(wLTable$sheetName, regexpr("_[0-9A-Za-z]+", wLTable$sheetName)))
#irrigation sampled column - weather its the first, second.. irrigation etc
wLTable$irrnum <- gsub('-', '',regmatches(wLTable$sheetName, regexpr("-[0-9A-Za-z]+$", wLTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(wLTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
wLTable <- wLTable[!na_inrow, ]
#Formate the date column to format the axis labels in ggplot
wLTable$date <- as.POSIXct(wLTable$date)
#write the final table to CSV if you want to save to text file
write.csv(wLTable,csvfile, row.names=FALSE)
dates
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
#Calculate water table  based on the moisture frome each measurement
samplings = length(dates)
waterLayerTable <- calculateWLayer(moistData,dates)
##Bind all samplings in one table (stack the rows, keep the columns)
wLTable <- Reduce(rbind,waterLayerTable)
##FORMATTING
#Format the headers (use if needed)
# wLTable$depth <- gsub('0-15', '1w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('15-30', '2w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('30-60', '3w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('60-90', '4w', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('0-15', 'depth1', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('15-30', 'depth2', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('30-60', 'depth3', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('60-90', 'depth4', wLTable$depth) #replace the depth by an ordered index
###########Separate the sheets name into columns (maybe change after the filtering thing?)
#The format should be something like: dr30-11-2015_pre-conv
#sheetname should be in a format dd-mm-yyyy and will have a prefix of 2 char: AR or DR or DT or MV (indicating the kind of sampling: after/before iirgation, etc)
#and a suffix indicating _[pre]/[2R]/[4R]-[1/2/3/4/5]/[pb]/[conv])
#date column - get what has the format of a date dd-mm-yyyy
wLTable$date <- as.Date(regmatches(wLTable$sheetName, regexpr("[0-9]{2}-[0-9]{2}-[0-9]{4}", wLTable$sheetName)),"%d-%m-%Y")
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, después, verano, trilla...)
wLTable$irrtype <- regmatches(wLTable$sheetName, regexpr("bi|ai|ah|m1", wLTable$sheetName)) #español ar|dr|mv|dt|m1"
#irrarea sampled column - the sampling corresponded to which irrigation instance: pre(siembra), 4R(4 riegos) or 2R(2 riegos)
wLTable$irrarea <- gsub('_', '',regmatches(wLTable$sheetName, regexpr("_[0-9A-Za-z]+", wLTable$sheetName)))
#irrigation sampled column - weather its the first, second.. irrigation etc
wLTable$irrnum <- gsub('-', '',regmatches(wLTable$sheetName, regexpr("-[0-9A-Za-z]+$", wLTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(wLTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
wLTable <- wLTable[!na_inrow, ]
#Formate the date column to format the axis labels in ggplot
wLTable$date <- as.POSIXct(wLTable$date)
#write the final table to CSV if you want to save to text file
write.csv(wLTable,csvfile, row.names=FALSE)
dates
file="C://Dropbox//data//AE//ae_stars//ser//AE-851 ANTILLON humedad.xlsx"
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
#Calculate water table  based on the moisture frome each measurement
samplings = length(dates)
waterLayerTable <- calculateWLayer(moistData,dates)
##Bind all samplings in one table (stack the rows, keep the columns)
wLTable <- Reduce(rbind,waterLayerTable)
##FORMATTING
#Format the headers (use if needed)
# wLTable$depth <- gsub('0-15', '1w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('15-30', '2w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('30-60', '3w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('60-90', '4w', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('0-15', 'depth1', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('15-30', 'depth2', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('30-60', 'depth3', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('60-90', 'depth4', wLTable$depth) #replace the depth by an ordered index
###########Separate the sheets name into columns (maybe change after the filtering thing?)
#The format should be something like: dr30-11-2015_pre-conv
#sheetname should be in a format dd-mm-yyyy and will have a prefix of 2 char: AR or DR or DT or MV (indicating the kind of sampling: after/before iirgation, etc)
#and a suffix indicating _[pre]/[2R]/[4R]-[1/2/3/4/5]/[pb]/[conv])
#date column - get what has the format of a date dd-mm-yyyy
wLTable$date <- as.Date(regmatches(wLTable$sheetName, regexpr("[0-9]{2}-[0-9]{2}-[0-9]{4}", wLTable$sheetName)),"%d-%m-%Y")
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, después, verano, trilla...)
wLTable$irrtype <- regmatches(wLTable$sheetName, regexpr("bi|ai|ah|m1", wLTable$sheetName)) #español ar|dr|mv|dt|m1"
#irrarea sampled column - the sampling corresponded to which irrigation instance: pre(siembra), 4R(4 riegos) or 2R(2 riegos)
wLTable$irrarea <- gsub('_', '',regmatches(wLTable$sheetName, regexpr("_[0-9A-Za-z]+", wLTable$sheetName)))
#irrigation sampled column - weather its the first, second.. irrigation etc
wLTable$irrnum <- gsub('-', '',regmatches(wLTable$sheetName, regexpr("-[0-9A-Za-z]+$", wLTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(wLTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
wLTable <- wLTable[!na_inrow, ]
#Formate the date column to format the axis labels in ggplot
wLTable$date <- as.POSIXct(wLTable$date)
#write the final table to CSV if you want to save to text file
write.csv(wLTable,csvfile, row.names=FALSE)
dates
endSheet <- 10
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
#Calculate water table  based on the moisture frome each measurement
samplings = length(dates)
waterLayerTable <- calculateWLayer(moistData,dates)
##Bind all samplings in one table (stack the rows, keep the columns)
wLTable <- Reduce(rbind,waterLayerTable)
##FORMATTING
#Format the headers (use if needed)
# wLTable$depth <- gsub('0-15', '1w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('15-30', '2w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('30-60', '3w', wLTable$depth) #replace the depth by an ordered index
# wLTable$depth <- gsub('60-90', '4w', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('0-15', 'depth1', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('15-30', 'depth2', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('30-60', 'depth3', wLTable$depth) #replace the depth by an ordered index
wLTable$depth <- gsub('60-90', 'depth4', wLTable$depth) #replace the depth by an ordered index
###########Separate the sheets name into columns (maybe change after the filtering thing?)
#The format should be something like: dr30-11-2015_pre-conv
#sheetname should be in a format dd-mm-yyyy and will have a prefix of 2 char: AR or DR or DT or MV (indicating the kind of sampling: after/before iirgation, etc)
#and a suffix indicating _[pre]/[2R]/[4R]-[1/2/3/4/5]/[pb]/[conv])
#date column - get what has the format of a date dd-mm-yyyy
wLTable$date <- as.Date(regmatches(wLTable$sheetName, regexpr("[0-9]{2}-[0-9]{2}-[0-9]{4}", wLTable$sheetName)),"%d-%m-%Y")
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, después, verano, trilla...)
wLTable$irrtype <- regmatches(wLTable$sheetName, regexpr("bi|ai|ah|m1", wLTable$sheetName)) #español ar|dr|mv|dt|m1"
#irrarea sampled column - the sampling corresponded to which irrigation instance: pre(siembra), 4R(4 riegos) or 2R(2 riegos)
wLTable$irrarea <- gsub('_', '',regmatches(wLTable$sheetName, regexpr("_[0-9A-Za-z]+", wLTable$sheetName)))
#irrigation sampled column - weather its the first, second.. irrigation etc
wLTable$irrnum <- gsub('-', '',regmatches(wLTable$sheetName, regexpr("-[0-9A-Za-z]+$", wLTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(wLTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
wLTable <- wLTable[!na_inrow, ]
#Formate the date column to format the axis labels in ggplot
wLTable$date <- as.POSIXct(wLTable$date)
#write the final table to CSV if you want to save to text file
write.csv(wLTable,csvfile, row.names=FALSE)
dates
library("XLConnect")
library(reshape2)
source(file.path("C:","Dropbox","Software","Scripts","r","moisture","methods_moisture.R", fsep = .Platform$file.sep))
setwd("C://Dropbox//Software//Scripts//r//moisture")
setwd("C://Dropbox//Software//Scripts//r//moisture")
file="C://Dropbox//Bascula (1)//Muestras suelo//AF//AF-710COMPASS.xlsx"
trial <- "710"
setwd("C://Dropbox//Software//Scripts//r//moisture")
file="C://Dropbox//Bascula (1)//Muestras suelo//AF//AF-710COMPASS.xlsx"
trial <- "710"
col_names<-c('id',
'depth',
'canType',
'can',
'wSoilw',
'dSoilw',
'moisture')
colTypes <- c('numeric', 'character','numeric', 'numeric','numeric','numeric','numeric')
##Check this for every excel read
startRow<- 6 #Skip the fisrt 5 rows because it has other ancillary data
startSheet <- 2
endSheet <- 10
endCol <- 7
endRow <- 66
csvfile <- "C://Dropbox//Bascula (1)//Muestras suelo//AF//AF-710COMPASS.csv"
##Edit next
##getMoistreFromExcel <- function (file, startSheet,endCol,endRow,colTypes,col_names,maxsamplepointID)
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
dates
moistData
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
dates
moistData
samplings = length(dates)
waterLayerTable <- calculateWLayer(moistData,dates)
samplings
moistData
##Edit next
##getMoistreFromExcel <- function (file, startSheet,endCol,endRow,colTypes,col_names,maxsamplepointID)
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
dates
moistData
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
moistData
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
moistData
samplings = length(dates)
waterLayerTable <- calculateWLayer(moistTable1,dates)
waterLayerTable <- calculateWLayer(moistData,dates)
samplings
waterLayerTable <- calculateWLayer(moistData,dates)
moistData
waterLayerTable <- calculateWLayer(moistData,dates)
for (s in 1:length(dates)) {
#Calculate the water layer for each sample
sPoints = length(moistData[[s]]$moisture) #total samples per date
for (i in 1:sPoints) {
moistData[[s]]$sheetName[i] <- as.character(sheets[s]) #add date info in  column
}
}
for (s in 1:length(dates)) {
#Calculate the water layer for each sample
sPoints = length(moistData[[s]]$moisture) #total samples per date
for (i in 1:sPoints) {
moistData[[s]]$sheetName[i] <- as.character(dates[s]) #add date info in  column
}
}
moistData
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
moistData
mTable <- moistData
for (s in 1:samplings) {
#Calculate the water layer for each sample
sPoints = length(mTable[[s]]$moisture) #total samples per date
for (i in 1:sPoints) {
mTable[[s]]$sheetName[i] <- as.character(dates[s]) #add date info in  column
}
}
mTable
mTable <- Reduce(rbind,mTable)
mTable
###########Separate the sheets name into columns (maybe change after the filtering thing?)
#The format should be something like: dr30-11-2015_pre-conv
#sheetname should be in a format dd-mm-yyyy and will have a prefix of 2 char: AR or DR or DT or MV (indicating the kind of sampling: after/before iirgation, etc)
#and a suffix indicating _[pre]/[2R]/[4R]-[1/2/3/4/5]/[pb]/[conv])
#date column - get what has the format of a date dd-mm-yyyy
mTable$date <- as.Date(regmatches(mTable$sheetName, regexpr("[0-9]{2}-[0-9]{2}-[0-9]{4}", mTable$sheetName)),"%d-%m-%Y")
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, despu?s, verano, trilla...)
mTable$irrtype <- regmatches(mTable$sheetName, regexpr("bi|ai|ah|m1", mTable$sheetName)) #espa?ol ar|dr|mv|dt|m1"
mTable
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, despu?s, verano, trilla...)
mTable$irrtype <- regmatches(mTable$sheetName, regexpr("dr", mTable$sheetName)) #espa?ol ar|dr|mv|dt|m1"
#irrarea sampled column - the sampling corresponded to which irrigation instance: pre(siembra), 4R(4 riegos) or 2R(2 riegos)
mTable$irrarea <- gsub('_', '',regmatches(mTable$sheetName, regexpr("_[0-9A-Za-z]+", mTable$sheetName)))
#irrigation sampled column - weather its the first, second.. irrigation etc
mTable$irrnum <- gsub('-', '',regmatches(mTable$sheetName, regexpr("-[0-9A-Za-z]+$", mTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(mTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
mTable <- mTable[!na_inrow, ]
#Formate the date column to format the axis labels in ggplot
mTable$date <- as.POSIXct(mTable$date)
mTable
write.csv(mTable,csvfile, row.names=FALSE)
mData <- getMoistreFromExcel(file, startSheet,endSheet,endCol,endRow,colTypes,col_names,startRow) #get the raw moisture data[[1]] and sheetnames[[2]]
##Resulting data
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
mData
dates<-unlist(mData[[2]])
moistData <-mData[[1]]
dates
moistData
samplings = length(dates)
mTable <- moistData
for (s in 1:samplings) {
#Calculate the water layer for each sample
sPoints = length(mTable[[s]]$moisture) #total samples per date
for (i in 1:sPoints) {
mTable[[s]]$sheetName[i] <- as.character(dates[s]) #add date info in  column
}
}
mTable <- Reduce(rbind,mTable)
mTable$date <- as.Date(regmatches(mTable$sheetName, regexpr("[0-9]{2}-[0-9]{2}-[0-9]{4}", mTable$sheetName)),"%d-%m-%Y")
#sampling type column - what looks like [dr]/[ar]/[mv]/[dt] ... (antes de riego, despu?s, verano, trilla...)
mTable$irrtype <- regmatches(mTable$sheetName, regexpr("dr", mTable$sheetName)) #espa?ol ar|dr|mv|dt|m1"
#irrarea sampled column - the sampling corresponded to which irrigation instance: pre(siembra), 4R(4 riegos) or 2R(2 riegos)
mTable$irrarea <- gsub('_', '',regmatches(mTable$sheetName, regexpr("_[0-9A-Za-z]+", mTable$sheetName)))
#irrigation sampled column - weather its the first, second.. irrigation etc
mTable$irrnum <- gsub('-', '',regmatches(mTable$sheetName, regexpr("-[0-9A-Za-z]+$", mTable$sheetName)))
#check for NA's in rows
na_inrow <- apply(mTable, 1, function(x){any(is.na(x))}) # logical vector of the rows with any NA's
#wLTable <- wLTable[complete.cases(wLTable), ] #This iis to remove any row that has a NA on it.
#keep only the rows that dont have NA's and their treatment correspond to the performed sampling
mTable <- mTable[!na_inrow, ]
mTable$date <- as.POSIXct(mTable$date)
write.csv(mTable,csvfile, row.names=FALSE)
